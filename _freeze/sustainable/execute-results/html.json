{
  "hash": "5d379b73cf19814edb0d29b0f355021f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Sustainable Heart Rate Levels in Crickles\"\nauthor: \"Ian Green\"\ndate: today\nformat: \n  html:\n    self-contained: true\n    toc: true\n    toc-depth: 2\n    number-sections: true\neditor: visual\nparams:\n  athlete: 320170\n  sample_id: \"13038162852\"\nexecute:\n  freeze: auto  \n---\n\n\n\n\n## Introduction\n\nHere we show how Crickles calculates Sustainable Heart Rate. The methodology is described and code snippets in R are given to illustrate the exact calculations. For non-R-programmers the snippets are broadly readable once you grasp that **\\|\\>** means *then*, **mutate** is defining a variable and **map** (and variants such as **map_dbl**) is an instruction to run a function over a range of values. If you prefer you can just skip over all the grey boxes that show code.\n\nSustainable Heart Rate is used in the setting of zones and in the determination of Cardiac Stress; the latter requires much more sophisticated modelling and will be documented separately.\n\nSustainable Heart Rate in this context is taken to be the heart rate that an athlete can sustain for one hour. This is preferred over maximum heart rate for purposes such as zone setting as it is more stable and less susceptible to the frequent heart rate measurement anomalies observed when using chest straps and sports watches. It can be thought of as an alternative to the use of Lactate Threshold Heart Rate (LTHR) in this regard. Since we lack the ability to measure blood lactate or inhaled and exhaled gases, LTHR is not available to us whereas sustainable heart rate can be directly measured.\n\nThe process for determining sustainable heart rate is described in three sections:\n\n1.  *Preparation*. Mainly this is data preparation. Since this is not generally replicable by the reader, what it needs to achieve is described in place of the actual process of data gathering.\n\n2.  *Background analysis*. This is the analysis of a history of data in order to determine certain values that will be used to estimate Sustainable Heart Rate in each case.\n\n3.  *Application to individuals*. Here we describe how the Sustainable Heart Rate and associated data shown in Crickles is derived.\n\n## Preparation\n\nIn code not shown here we load three data sets:\n\n1.  **selection** - a sample of activities over a three year period from athletes who were active before the start and after the end of that period. We include activities only from athletes who did at least 30 with heart rate data of over an hour or more in each of the three years. We only include activities that have a Crickles *Regularity* value of **Regular** in order to screen out activities where the chest strap or sports watch recording the heart rate was not performing correctly.\n\n2.  **athlete_age** - a dataframe simply giving the age of each athlete at the mid point of the middle year in the three year range.\n\n3.  **sample_athlete** - a dataframe of all historical activities for a sample Crickles user.\n\nIn addition, we define a function called **fetch_streams()** that gets the stream-level data - typically second by second heart rate - for a given activity.\n\n\n\n\n::: {.cell messages='false' warnings='false'}\n\n:::\n\n::: {.cell messages='false' warnings='false'}\n\n:::\n\n\n\n\n## Background analysis\n\nAlthough we use Sustainable Heart Rate as a reference point in time, we are usually interested in efforts over shorter time windows than one hour. Fortunately, there are stable relationships between sustainable heart rate levels over different time windows and we can use these to baseline efforts over a range of different time windows to an hour-equivalent rate.\n\nWe use historical data to establish what these relationships are and to confirm their stability.\n\n\n\n\n::: {.cell messages='false' warnings='false'}\n\n```{.r .cell-code}\n# first we define a ladder of four functions needed to calc sustainable \n# heart rate levels over a number of time windows for many athletes\n\n# 1 - function to get hr windows for one streams file\nhr_windows <- function(streams) {\n  \n  if (!\"heartrate\" %in% names(streams)) {\n    message(\"No heartrate\")\n    return(NA)\n  }\n  \n  # If necessary, complete time series and fill gaps\n  if (nrow(streams) != max(streams$time) + 1) {\n    max_ok_gap <- 10\n    min_heartrate <- min(streams$heartrate, na.rm = TRUE)\n\n    streams <- streams |>\n      mutate(next_gap = lead(time) - time,\n             heartrate = if_else(next_gap < max_ok_gap, heartrate, min_heartrate)) |>\n      complete(time = full_seq(time, period = 1)) |>\n      fill(heartrate)\n  }\n  \n  # specify the windows and remove any that are longer than the activity\n  grid <- 60 * c(6, 20, 40, 60)\n  grid <- grid[grid <= max(streams$time, na.rm = TRUE)]\n  \n  # calculate the max sustained hr for each window and return the list\n  result <- map_dbl(grid, \\(x) max(rollmean(streams$heartrate, x, partial = FALSE), \n                                   na.rm = TRUE))\n  output <- replace(rep(NA, 4), \n                    seq_along(result), \n                    ifelse(is.finite(result), result, NA))\n  names(output) <- c(\"HR_6\", \"HR_20\", \"HR_40\", \"HR_60\")\n  return(as.list(output))\n}\n\n# 2 - function to get the hr windows for a set of activities\nmany_windows <- function(acts) {\n  safe_fetch_hr <- possibly(\\(athlete, act_id) fetch_streams(athlete, act_id) |> \n                              hr_windows(),\n                            otherwise = NULL)\n  \n  map2_df(acts$athlete_id, acts$id, safe_fetch_hr)\n}\n\n# 3 - function to process a set of activities by athlete\nathlete_windows <- function(acts, athlete) {\n  acts |> filter(athlete_id == athlete) |> \n    group_by(year) |> \n    nest() |> \n    mutate(results = map(data, \\(x) suppressWarnings(many_windows(x)))) |> \n    unnest(results) |> \n    summarise(\n      max_6  = max(HR_6,  na.rm = TRUE), \n      max_20 = max(HR_20, na.rm = TRUE), \n      max_40 = max(HR_40, na.rm = TRUE), \n      max_60 = max(HR_60, na.rm = TRUE)) |> \n    select(- year) |> \n    map(median) |>\n    as_tibble() |>\n    mutate(ratio_6 = max_60/max_6,\n           ratio_20 = max_60/max_20,\n           ratio_40 = max_60/max_40)\n}\n\n# 4 - function to process a set of activities for many athletes\nmany_athletes <- function(acts) {\n  plan(multisession, workers = 8)\n  athletes <- unique(acts$athlete_id)\n  result <- future_map_dfr(\n    athletes, \n    possibly(\\(athlete) {\n      athlete_windows(acts, athlete) |> \n        mutate(athlete_id = athlete)\n    }, \n    otherwise = NULL))\n  return(result)\n}\n\n# now, run the last function to get a dataframe for all athletes:\nall_athletes <- many_athletes(selection)\n```\n:::\n\n\n\n::: {.cell messages='false' warnings='false'}\n\n```{.r .cell-code}\n# now we can prepare visualisations of the analysis,\n# starting with a boxplot:\n\nx_order_ratio <- c(\"ratio_6\", \"ratio_20\", \"ratio_40\")\n\nbox_plot <- all_athletes |>\n  pivot_longer(cols = c(ratio_6, ratio_20, ratio_40), \n               names_to = \"variable\", \n               values_to = \"value\") |>\n  mutate(variable = factor(variable, levels = x_order_ratio)) |>\n  ggplot(aes(x = variable, y = value)) +\n    geom_boxplot() +\n    labs(title = \"Distribution of ratios across athletes\", \n         x = \"window\", \n         y = \"ratio to 1 hour\") +\n    theme_minimal()\n\nif (!is.null(params$athlete)) {\n  overlay_point <- all_athletes |>\n  filter(athlete_id == params$athlete) |>\n  select(all_of(x_order_ratio)) |>\n  pivot_longer(cols = everything(), \n               names_to = \"variable\", \n               values_to = \"point_value\") |>\n  mutate(variable = factor(variable, levels = x_order_ratio))\n  box_plot <- box_plot +\n    geom_point(data = overlay_point, \n               aes(x = variable, y = point_value),\n                color = \"red\", \n                size = 3, \n                shape = 18)\n}\n\nbox_plot\n```\n\n::: {.cell-output-display}\n![](sustainable_files/figure-html/boxplot-1.png){width=672}\n:::\n:::\n\n\n\n\nThe box plot shows the range of values for each of the ratios. The red lozenges show the values for our sample athlete whose data we'll be looking at later.\n\nThe median values across all athletes can be summarised as follows:\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n   max_6   max_20   max_40   max_60  ratio_6 ratio_20 ratio_40 \n 175.906  170.557  166.559  161.808    0.919    0.951    0.979 \n```\n\n\n:::\n:::\n\n\n\n\nHere the max\\_ values show the median maximum heart rate for the period in minutes shown. For example, max_20 gives the median heart rate that can be sustained for 20 minutes by this sample of athletes on Crickles. The ratio\\_ values, which are ultimately more important in Crickles, are the median values of the ratio between the sustainable rate over one hour and the corresponding period, respectively. For example, ratio_20 is the median value of the 60 minutes sustainable heart rate over the 20 minute sustainable heart rate; ratio_60 isn't shown because by definition it would always be 1. These ratios enable us to infer what levels sustained over different durations might imply for the capacity to sustain a heart rate for an hour.\n\nWe're going to use ratio_n values to calculate sustainable heart rate so it matters that they're stable and reasonably consistent between athletes. Experience shows that they don't change much over time. We can get a measure of their stability across athletes by looking at the interquartile range, or spread of the majority of the values, as a proportion of the median:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_athletes |> \n  select(-athlete_id) |> \n  map_dbl(\\(x) (100 * IQR(x)/median(x)) |> round(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   max_6   max_20   max_40   max_60  ratio_6 ratio_20 ratio_40 \n     7.4      9.6      9.1      9.0      3.8      3.5      2.0 \n```\n\n\n:::\n:::\n\n\n\n\nThis shows that there is much less dispersion of the ratios than there is of the maximum values, and it's the ratios that we need to be consistent across time and athletes. Taking ratio_20 as an example again, this shows that half of the athletes have values lying in a band around the median whose width is 3.5% of the median value (so most would be within 2% of the median).\n\nWe might wonder whether the ratios change as athletes age. We know that maximum heart rates does, and we can verify that here. For example, we can show the tendency for the heart rate that can be sustained for 20 minutes to decline with age:\n\n\n\n\n::: {.cell messages='false'}\n\n```{.r .cell-code}\nall_athletes <- all_athletes |> \n  left_join(athlete_age) \n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(athlete_id)`\n```\n\n\n:::\n\n```{.r .cell-code}\nall_athletes |> \n  ggplot(aes(x = age, y = max_20)) +\n    geom_point() +\n    geom_smooth(method = \"lm\", se = F) +\n    theme_light() +\n    labs(title = \"Sustainable 20 minute heart rate as a function of age\",\n          y = \"bpm\",\n          caption = paste(\"Source: Crickles. n: \", nrow(all_athletes)))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](sustainable_files/figure-html/hr vs age-1.png){width=672}\n:::\n:::\n\n\n\n\nThere is no such relationship between the ratios and age. To get a better sense of the relationship between all of these variables and age we can look at a correlation matrix:\n\n\n\n\n::: {.cell messages='false' warnings='false'}\n\n```{.r .cell-code}\nall_athletes |> \n  select(-athlete_id) |> \n  cor() |> \n  as.table() |> \n  as.data.frame() |> \n  setNames(c(\"Var1\", \"Var2\", \"Correlation\")) |> \n  ggplot(aes(Var1, Var2, fill = Correlation)) +\n  geom_tile(color = \"white\") + \n  geom_text(aes(label = scales::label_number(accuracy = 0.01)(Correlation),\n                color = abs(Correlation) < 0.5), \n                size = 3.5) + \n  scale_fill_gradient2(low = \"blue\", \n                       mid = \"white\", \n                       high = \"red\", \n                       midpoint = 0) +\n  scale_color_manual(values = c(\"black\", \"white\"), \n                     guide = \"none\") + \n  theme_minimal() +\n  labs(title = \"Correlation Matrix\", \n       fill = \"Correlation\", \n       x = \"\", \n       y = \"\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](sustainable_files/figure-html/correlations-1.png){width=672}\n:::\n:::\n\n\n\n\nIt is evident that age correlates strongly (and negatively) with maximum heart rate levels - about 60% in all windows - but only inconsequentially with the ratios.\n\n## Application to individual athletes\n\nThe calculation of Sustainable Heart Rate is in two steps:\n\n1.  For each activity where heart rate is recorded the observed maximum heart rate over each of the time windows cited above is calculated. Each of these is weighted, also as above, to convert it to an estimate of a one hour equivalent. The maximum of these is recorded as the **spot_hr** for that activity. The purpose of this is to use information from a number of different time windows as it is only relatively rarely that an athlete will operate at or over threshold for an hour or more.\n\n2.  At any point in time Crickles looks back to find the maximum recent spot_hr value. Recency is important as fitness, including cardiac fitness, varies seasonally and with age and a performance observed, say, a year ago may not be repeatable today. Conversely, it is necessary to look back far enough to capture any efforts that are still indicative of current fitness. The Sustainable Heart Rate calculation aims to attain a balance that captures relevantly recent activities while discarding observations as they become stale.\n\n### Determining spot_hr\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# We create a function that calculates the maximum sustained hr over each window\n# and then converts these to an hour equivalent using the weights found above.\n\n# First, we make a function that does this given 'streams'...\nhr_windows_weighted <- function(streams) {  \n  \n  # Define HR weights explicitly\n  weights <- c(HR_6 = 0.913, HR_20 = 0.954, HR_40 = 0.98, HR_60 = 1)\n\n  # Safely compute sustainable HR values\n  sus_windows <- possibly(hr_windows, \n                          otherwise = setNames(rep(NA_real_, length(weights)), names(weights)))(streams)\n\n  sus_windows <- unlist(sus_windows)[names(weights)] \n\n  # Calculate weighted HR\n  weighted_hr <- sus_windows * weights\n\n  # Find max weighted HR, handling NA\n  spot_hr <- suppressWarnings(max(weighted_hr, na.rm = TRUE))\n  if (!is.finite(spot_hr)) spot_hr <- NA_real_\n\n  # Find corresponding window length and extract numeric part\n  spot_window <- if (!is.na(spot_hr)) {\n    names(weighted_hr)[which.max(weighted_hr)] |> \n      str_remove(\"HR_\") |> \n      as.numeric()\n  } else {\n    NA_real_\n  }\n\n  # Return formatted list\n  list(\n    spot_hr = round(spot_hr, 1),\n    best_window = spot_window,\n    all_weighted_hr = round(weighted_hr, 1)\n  )\n}\n\n# Then we wrap this in a function that takes an activity id...\nactivity_windows_weighted <- function(act_ID) {\n  safe_fetch_streams <- possibly(fetch_streams, \n                                 otherwise = NULL)\n  safe_hr_windows_weighted <- possibly(hr_windows_weighted, \n                                       otherwise = list(spot_hr = NA))\n  this_streams <- safe_fetch_streams(params$athlete, act_ID)\n  \n  if (is.null(this_streams)) return(NA)\n  results <- safe_hr_windows_weighted(this_streams)\n  return(results$spot_hr)\n}\n```\n:::\n\n\n\n\nAs an example, take an activity that has this heart rate chart:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsample <- fetch_streams(params$athlete, params$sample_id) \nsample |>\n  mutate(minutes = time/60) |>\n  ggplot(aes(x = minutes, y = heartrate)) +\n  geom_point(col = \"red\") +\n  geom_line(col = \"red3\") +\n  theme_light()\n```\n\n::: {.cell-output-display}\n![](sustainable_files/figure-html/sample chart-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can find the sustained heart rate over each of the time windows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_windows(sample) |> unlist() |> round(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n HR_6 HR_20 HR_40 HR_60 \n131.2 125.2 122.2 118.2 \n```\n\n\n:::\n:::\n\n\n\n\nFor example, the value labelled HR_20 is the highest heart rate that was sustained for 20 minutes.\n\nUsing this information together with the equivalency weights, we calculate the spot_hr and show the time window on which this is based:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhr_windows_weighted(sample)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$spot_hr\n[1] 119.8\n\n$best_window\n[1] 6\n\n$all_weighted_hr\n HR_6 HR_20 HR_40 HR_60 \n119.8 119.5 119.7 118.2 \n```\n\n\n:::\n:::\n\n\n\n\nIn this example, the short effort spike that can be seen on the chart almost half way through the activity gives us the highest estimate for the one hour sustainable heart rate so we use that.\n\nThe *spot_hr*, being the estimated sustained heart rate for each individual activity, is shown in Crickles on the *Activities* page as is the corresponding time window, which appears as *Best_HR_Bucket*.\n\n### Sustainable Heart Rate\n\nFrom the history of spot_hr's for each activity with heart rate data we need to compute a sustainable heart rate estimate for each point in time. For this, we must observe and remember the greatest recent effort, remembering that it is relatively rare for an athlete to push themselves to the limit. The way that Crickles currently composes a sustainable heart rate estimate from the history of spot_hr's is to average the highest value from the last four weeks and the highest value from the last twelve weeks (which may be the same). The rationale for this is as follows... As fitness varies, we take the last four week period to be definitive for current fitness. On the other hand, observations taken from over twelve weeks (almost a quarter) into the past are taken to be stale from the perspective of current capability. Observations of spot_hr from between four and the twelve weeks ago can still colour the current estimate but cannot wholly define it.\n\nWe can illustrate this with an example.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sample_athlete is a dataframe of activities for one sample athlete\n# here we calculate the spot_hr for each one\nplan(multisession, workers = 8)\nsample_athlete$spot_hr <- future_map_dbl(sample_athlete$ID, activity_windows_weighted) \nplan(sequential)\n\n# a bit of renaming...\nsample_athlete <- sample_athlete |> \n  rename(start_date_local = Date,\n         id = ID)\n\n# now we define a function to roll up sustainable hr as described\nsus_hr <- function(acts) {\nacts |>\n  arrange(start_date_local) |>\n  mutate(date1 = ymd(as.Date(start_date_local)),\n         spot_hr_valid = ifelse(Regular == \"Regular\", spot_hr, NA)) |>\n  complete(date1 = full_seq(date1, period = 1)) |>\n  fill(spot_hr, spot_hr_valid) |>\n  mutate(sus_hr_short = rollmax(spot_hr_valid,\n                                28,\n                                align = \"right\",\n                                na.rm = TRUE,\n                                fill = NA),\n          sus_hr_long = rollmax(spot_hr_valid,\n                                84,\n                                align = \"right\",\n                                na.rm = TRUE,\n                                fill = NA),\n          sustainable_hr = round(0.5*(sus_hr_short + sus_hr_long),1)) |>\n  select(-c(date1, sus_hr_short, sus_hr_long, spot_hr_valid)) |>\n  drop_na(id) |>\n  arrange(desc(start_date_local)) -> acts\nreturn(acts)\n}\n\n# and see how that applies to our sample athlete:\nsus_hr(sample_athlete) |> \n  ggplot(aes(x = start_date_local)) +\n  geom_point(aes(y = spot_hr), col = \"grey\", alpha = 0.5) +\n  geom_line(aes(y = sustainable_hr), col = \"seagreen\") +\n  theme_light() +\n  labs(title = \"Sustainable heart rate (line) over spot_hr (points)\", \n       x = \"date\",\n       y = \"heart rate (bpm)\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 39 rows containing missing values or values outside the scale range\n(`geom_line()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](sustainable_files/figure-html/sustainable_hr-1.png){width=672}\n:::\n:::\n\n\n\n\nWe can see that, while there are many different methods we could use to calculate sustainable heart rate including some that give a less stepped line, the method that we use does a good job of sitting just above the spot_hr values. Those points that lie on the green line are precisely those for activities whose heart rate intensity, shown as **HRI** on the *Activities* page, is \\>= 1. On the Crickles Navigator *Timeline* page this is shown as **Intensity** in the tool tip for each point with heart rate data, where it is multiplied by 100 (so, for example, 90 instead of 0.9).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}